package com.example.vulnerable.controller;

import com.example.vulnerable.model.User;
import com.example.vulnerable.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Map;
import java.util.Set;

@RestController
@RequestMapping("/api/advanced")
public class AdvancedVulnerabilityController {

    @Autowired
    private UserRepository userRepository;

    // 1. Mass Assignment Fix: Use a dedicated DTO
    @PostMapping("/user/update")
    public String updateUser(@RequestBody Map<String, String> updateMask) {
        // SECURE: Manually map only allowed fields
        String idStr = updateMask.get("id");
        if (idStr == null)
            return "ID required";

        userRepository.findById(Long.parseLong(idStr)).ifPresent(user -> {
            if (updateMask.containsKey("username"))
                user.setUsername(updateMask.get("username"));
            // NEVER update role from a generic user update endpoint
            userRepository.save(user);
        });
        return "User updated safely.";
    }

    // 2. Unsafe Reflection Fix: Whitelist allowed classes/methods
    private static final Set<String> ALLOWED_REFLECT = Set.of("java.lang.String");

    @GetMapping("/reflect")
    public String reflect(@RequestParam String className, @RequestParam String methodName) {
        try {
            if (!ALLOWED_REFLECT.contains(className))
                return "Class not allowed";

            Class<?> clazz = Class.forName(className);
            Object obj = clazz.getDeclaredConstructor().newInstance();
            Method method = clazz.getDeclaredMethod(methodName);
            return "Result: " + method.invoke(obj);
        } catch (Exception e) {
            return "Reflection failed safely.";
        }
    }

    // 3. Business Logic Fix: Proper validation
    @PostMapping("/cart/checkout")
    public String checkout(@RequestParam int quantity, @RequestParam double price) {
        // SECURE: Validate inputs
        if (quantity <= 0 || price <= 0) {
            return "Invalid quantity or price.";
        }
        double total = quantity * price;
        return "Total charged: " + total + ". Success!";
    }

    // 4. Insecure Temporary Files Fix: Set strict permissions
    @GetMapping("/temp-data")
    public String createTempData(@RequestParam String content) throws IOException {
        // SECURE: Create temp file with restricted permissions (Unix-specific example)
        File tempFile = File.createTempFile("secure-app-", ".txt");
        try {
            Files.setPosixFilePermissions(tempFile.toPath(), PosixFilePermissions.fromString("rw-------"));
        } catch (UnsupportedOperationException e) {
            // Fallback for non-POSIX
            tempFile.setReadable(false, false);
            tempFile.setReadable(true, true);
        }
        Files.write(tempFile.toPath(), content.getBytes());
        return "Data stored safely in " + tempFile.getAbsolutePath();
    }

    // 5. Race Condition Fix: Synchronize access
    private double balance = 1000.0;
    private final Object balanceLock = new Object();

    @PostMapping("/transfer")
    public String transfer(@RequestParam double amount) throws InterruptedException {
        // SECURE: Use a lock or AtomicDouble to prevent race conditions
        synchronized (balanceLock) {
            if (balance >= amount) {
                Thread.sleep(100);
                balance -= amount;
                return "Transfer successful. Remaining balance: " + balance;
            }
        }
        return "Insufficient funds. Balance: " + balance;
    }

    // 6. PII in URL Fix: Use POST and body
    @PostMapping("/user-details")
    public String getUserDetails(@RequestBody Map<String, String> sensitiveData) {
        // SECURE: Sensitive data is in the body, not query params
        return "Details for " + sensitiveData.get("email") + " processed securely.";
    }

    // 7. JWT Validation Fix: Use proper verification (simulated)
    @GetMapping("/admin-check")
    public String adminCheck(@RequestHeader("Authorization") String token) {
        // SECURE: Perform full cryptographic validation of the token
        if (token != null && token.startsWith("Bearer ") && token.length() > 50) {
            // Real apps would use
            // Jwts.parser().verifyWith(key).build().parseSignedClaims(token)
            return "Token valid. Welcome Admin!";
        }
        return "Invalid or missing token.";
    }

    // 8. Parameter Pollution Fix: Explicitly bind needed parameters
    @GetMapping("/settings")
    public String updateSettings(@RequestParam(required = false) String theme,
            @RequestParam(required = false) String lang) {
        // SECURE: Only accept and use specific, expected parameters
        return "Applied theme: " + theme + ", lang: " + lang;
    }
}
